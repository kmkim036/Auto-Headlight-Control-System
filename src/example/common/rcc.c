/**
  *****************************************************************************
  * @title   RCC_Exp.c
  * @author  CooCox
  * @date    12 Nov 2013
  * @brief   STM32F4xx RCC Example
  *******************************************************************************
  */
////// The above comment is automatically generated by CoIDE ///////////////////

/**
  ******************************************************************************
  * @file    RCC/RCC_Exp/main.c
  * @author  MCD Application Team
  * @version V1.0.0
  * @date    30-September-2011
  * @brief   Main program body
  ******************************************************************************
  * @attention
  *
  * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  ******************************************************************************
  */

/*
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stm32f4xx_rcc.h"
//#include "misc.h"
*/
#include <string.h>
#include <stdarg.h>
#include "stm32f10x.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_usart.h"
#include "stm32f10x_i2c.h"
#include "stm32f10x_rcc.h"
#include "stm32f10x_exti.h"
#include "misc.h"
#include "cmdline.h"
#include "yInc.h"
/** @addtogroup STM32F4xx_StdPeriph_Examples
  * @{
  */

/** @addtogroup RCC_Example
  * @{
  */

/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/* Private macro -------------------------------------------------------------*/
/* Private variables ---------------------------------------------------------*/
/* Private function prototypes -----------------------------------------------*/
void LEDInit(void);
void Delay (uint32_t nCount);
void NMI_Handler(void);
void RCC_IRQHandler(void);


static ErrorStatus MCO_init(void) {
	ErrorStatus status = ERROR;
	GPIO_InitTypeDef GPIO_InitStructure;
#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F103RCT6)|| (PROCESSOR == PROCESSOR_STM32F107VCT)|| (PROCESSOR == PROCESSOR_GD32F130FX))
#else
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	RCC_MCO2Config(RCC_MCO2Source_PLLCLK, RCC_MCO2Div_5);
#endif
	somedelay(9999);
	return (status);
}
void MCO1_Config_25MHz(void){
	GPIO_InitTypeDef GPIO_InitStructure;

#if ((PROCESSOR == PROCESSOR_STM32F103C8T6)|| (PROCESSOR == PROCESSOR_STM32F103RCT6) || (PROCESSOR == PROCESSOR_STM32F107VCT)|| (PROCESSOR == PROCESSOR_GD32F130FX))
#else
	//=============================================================
	//RCC_PLLCmd(DISABLE);
	// Output HSE clock on MCO1 pin(PA8)
	// Enable the GPIOA peripheral
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	// Configure MCO1 pin(PA8) in alternate function
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// HSE clock selected to output on MCO1 pin(PA8)
	RCC_MCO1Config(RCC_MCO1Source_HSE, RCC_MCO1Div_1); //MCO1 (PA8) <= OSC (--> 25MHz)

	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
	//RCC_PLLCmd(ENABLE);
#endif
}

void MCO2_Config_24MHz(void){
	GPIO_InitTypeDef GPIO_InitStructure;
#if ((PROCESSOR == PROCESSOR_STM32F103C8T6) || (PROCESSOR == PROCESSOR_STM32F103RCT6)|| (PROCESSOR == PROCESSOR_STM32F107VCT)|| (PROCESSOR == PROCESSOR_GD32F130FX))
#else
	// Output PLLI2SCLK clock on MCO2 pin(PC9) == 24MHz ======================================================
	// Enable the GPIOC peripheral
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
	/// Configure MCO2 pin(PC9) in alternate function
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	//GPIO_PinAFConfig(GPIOC, GPIO_PinSource9, GPIO_AF_MCO); //add

	//RCC_PLLConfig(RCC_MCO1Source_HSE);
	RCC_PLLI2SCmd(DISABLE);
	RCC_PLLI2SConfig(192,4);
	//RCC_I2SCLKConfig(RCC_I2SCLKSource);
	// PLLI2SCLK selected to output on MCO2 pin(PC9)
	RCC_MCO2Config(RCC_MCO2Source_PLLI2SCLK, RCC_MCO2Div_2); //MCO2 (PC9) <-- 24MHz (PLLI2SCLK 48MHz --> divide by 2)
	//RCC_MCO2Config(RCC_MCO2Source_HSE, RCC_MCO2Div_2); //MCO1 (PA8) <= OSC (--> 25MHz)
	RCC_PLLI2SCmd(ENABLE);
	//while(RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY) == RESET);
#endif
}
void rccLoop(void)
{

	//NVIC_InitTypeDef NVIC_InitStructure;
	RCC_ClocksTypeDef RCC_ClockFreq;

	/*!< At this stage the microcontroller clock setting is already configured,
       this is done through SystemInit() function which is called from startup
       file (startup_stm32f4xx.s) before to branch to application main.
       To reconfigure the default setting of SystemInit() function, refer to
       system_stm32f4xx.c file
     */

	/* Initialize LEDs mounted on STM324xG-EVAL board ***************************/
	//LEDInit();

	/* Turn on LED1 and LED3 */
	//GPIO_SetBits(GPIOG, GPIO_Pin_6);
	//GPIO_SetBits(GPIOI, GPIO_Pin_9);


	/* This function fills the RCC_ClockFreq structure with the current
     frequencies of different on chip clocks (for debug purpose) **************/
	RCC_GetClocksFreq(&RCC_ClockFreq);

	/* Enable Clock Security System(CSS): this will generate an NMI exception
     when HSE clock fails *****************************************************/
	//RCC_ClockSecuritySystemCmd(ENABLE);

	/* Enable and configure RCC global IRQ channel, will be used to manage HSE ready
     and PLL ready interrupts.
     These interrupts are enabled in stm32f4xx_it.c file **********************/
	//NVIC_InitStructure.NVIC_IRQChannel = RCC_IRQn;
	//NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	//NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	//NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	//NVIC_Init(&NVIC_InitStructure);

	MCO1_Config_25MHz();


	// Output PLLI2SCLK clock on MCO2 pin(PC9) == 24MHz ======================================================
	MCO2_Config_24MHz();


	while (1) {}
	/*
    // Toggle LED2 and LED4
    GPIOG->ODR ^= GPIO_Pin_6;
    GPIOC->ODR ^= GPIO_Pin_7;

    // Insert a delay
    somedelay(0x27FFFF);

    // Toggle LED1 and LED3
    GPIOG->ODR ^= GPIO_Pin_8;
    GPIOI->ODR ^= GPIO_Pin_9;

    // Insert a delay
    somedelay(0x27FFFF);
  //}
   * */

}

/*

// @brief   This function handles NMI exception.

void NMI_Handler(void)
{
  // This interrupt is generated when HSE clock fails
  if (RCC_GetITStatus(RCC_IT_CSS) != RESET)
  {
    // At this stage: HSE, PLL are disabled (but no change on PLL config) and HSI   is selected as system clock source

    // Enable HSE
    RCC_HSEConfig(RCC_HSE_ON);

    // Enable HSE Ready and PLL Ready interrupts
    RCC_ITConfig(RCC_IT_HSERDY | RCC_IT_PLLRDY, ENABLE);

    // Clear Clock Security System interrupt pending bit
    RCC_ClearITPendingBit(RCC_IT_CSS);

    /// Once HSE clock recover, the HSERDY interrupt is generated and in the RCC ISR
    //   routine the system clock will be reconfigured to its previous state (before
    //   HSE clock failure)
  }
}


//  * @brief  This function handles RCC interrupt request.
void RCC_IRQHandler(void)
{
  if(RCC_GetITStatus(RCC_IT_HSERDY) != RESET) {
    // Clear HSERDY interrupt pending bit
    RCC_ClearITPendingBit(RCC_IT_HSERDY);

    // Check if the HSE clock is still available
    if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
    {
      // Enable PLL: once the PLL is ready the PLLRDY interrupt is generated
      RCC_PLLCmd(ENABLE);
    }
  }

  if(RCC_GetITStatus(RCC_IT_PLLRDY) != RESET)
  {
    // Clear PLLRDY interrupt pending bit
    RCC_ClearITPendingBit(RCC_IT_PLLRDY);

    // Check if the PLL is still locked
    if (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) != RESET)
    {
      // Select PLL as system clock source
      RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    }
  }
}
*/
